diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
index 3453800..d45f9e1 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
@@ -125,29 +125,54 @@ class AuthenticationHelper(
     }
 
     val biometricManager = BiometricManager.from(context)
-    when (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG)) {
-      BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE, BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE -> {
-        promise.reject(
-          "ERR_SECURESTORE_AUTH_NOT_AVAILABLE",
-          "No hardware available for biometric authentication. Use expo-local-authentication to check if the device supports it."
-        )
-        return
-      }
-      BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED -> {
-        promise.reject(
-          "ERR_SECURESTORE_AUTH_NOT_CONFIGURED",
-          "No biometrics are currently enrolled"
-        )
-        return
+      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R) {
+        when (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG)) {
+          BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE, BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE -> {
+            promise.reject(
+              "ERR_SECURESTORE_AUTH_NOT_AVAILABLE",
+              "No hardware available for biometric authentication. Use expo-local-authentication to check if the device supports it."
+            )
+            return
+          }
+          BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED -> {
+            promise.reject(
+              "ERR_SECURESTORE_AUTH_NOT_CONFIGURED",
+              "No biometrics are currently enrolled"
+            )
+            return
+          }
+        }
+      } else {
+          val canAuthenticateWithBiometry = biometricManager
+              .canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG)
+          if (canAuthenticateWithBiometry != BiometricManager.BIOMETRIC_SUCCESS) {
+              val canAuthenticateWithPasscode = biometricManager
+                  .canAuthenticate(BiometricManager.Authenticators.DEVICE_CREDENTIAL)
+              if (canAuthenticateWithPasscode != BiometricManager.BIOMETRIC_SUCCESS) {
+                  promise.reject(
+                      "ERR_SECURESTORE_AUTH_NOT_CONFIGURED",
+                      "Nor device credentials nor biometrics are available"
+                  )
+                  return
+              }
+          }
       }
-    }
 
     val title = options.getString(AUTHENTICATION_PROMPT_PROPERTY, " ")
 
-    val promptInfo = PromptInfo.Builder()
-      .setTitle(title)
-      .setNegativeButtonText(context.getString(android.R.string.cancel))
-      .build()
+    val promptInfo = if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R) {
+      PromptInfo.Builder()
+        .setTitle(title)
+        .setNegativeButtonText(context.getString(android.R.string.cancel))
+        .build()
+    } else {
+      PromptInfo.Builder()
+        .setTitle(title)
+        .setAllowedAuthenticators(BiometricManager.Authenticators.BIOMETRIC_STRONG
+                  or BiometricManager.Authenticators.DEVICE_CREDENTIAL)
+        .build()
+    }
+
     val fragmentActivity = getCurrentActivity() as FragmentActivity?
     if (fragmentActivity == null) {
       promise.reject(
@@ -174,13 +199,12 @@ class AuthenticationHelper(
                 promise,
                 encryptionCallback,
                 cipher,
-                gcmParameterSpec,
-                { promise, result ->
-                  val obj = result as JSONObject
-                  obj.put(REQUIRE_AUTHENTICATION_PROPERTY, true)
-                  postEncryptionCallback?.run(promise, result)
-                }
-              )
+                gcmParameterSpec
+              ) { promise, result ->
+                val obj = result as JSONObject
+                obj.put(REQUIRE_AUTHENTICATION_PROPERTY, true)
+                postEncryptionCallback?.run(promise, result)
+              }
             }
 
             override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.java b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.java
index 91e9b85..b30bf8c 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.java
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.java
@@ -13,6 +13,8 @@ import android.text.TextUtils;
 import android.util.Base64;
 import android.util.Log;
 
+import androidx.biometric.BiometricManager;
+
 import org.json.JSONException;
 import org.json.JSONObject;
 import expo.modules.core.ExportedModule;
@@ -55,15 +57,21 @@ public class SecureStoreModule extends ExportedModule {
 
   private static final String SCHEME_PROPERTY = "scheme";
 
+  private static final int SECURITY_LEVEL_NONE = 0;
+  private static final int SECURITY_LEVEL_SECRET = 1;
+  private static final int SECURITY_LEVEL_BIOMETRIC = 2;
+
   private KeyStore mKeyStore;
   private AESEncrypter mAESEncrypter;
   private HybridAESEncrypter mHybridAESEncrypter;
   private AuthenticationHelper mAuthenticationHelper;
+  private BiometricManager biometricManager;
 
   public SecureStoreModule(Context context) {
     super(context);
     mAESEncrypter = new AESEncrypter();
     mHybridAESEncrypter = new HybridAESEncrypter(context, mAESEncrypter);
+    biometricManager = BiometricManager.from(context);
   }
 
   @Override
@@ -76,6 +84,31 @@ public class SecureStoreModule extends ExportedModule {
     return TAG;
   }
 
+  @ExpoMethod
+  @SuppressWarnings("unused")
+  public void getEnrolledLevelAsync(Promise promise) {
+    int level = SECURITY_LEVEL_NONE;
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R) {
+      int result = biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG);
+      Log.d(TAG, "BIOMETRIC_STRONG " + Integer.toString(result));
+      if (result == BiometricManager.BIOMETRIC_SUCCESS) {
+        level = SECURITY_LEVEL_BIOMETRIC;
+      }
+    } else {
+      int biometricResult = biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG);
+      if (biometricResult == BiometricManager.BIOMETRIC_SUCCESS) {
+        level = SECURITY_LEVEL_BIOMETRIC;
+      }
+      int deviceCredentialResult = biometricManager.canAuthenticate(BiometricManager.Authenticators.DEVICE_CREDENTIAL);
+      if (deviceCredentialResult == BiometricManager.BIOMETRIC_SUCCESS) {
+        level = SECURITY_LEVEL_SECRET;
+      }
+    }
+    promise.resolve(level);
+  }
+
   // NOTE: This currently doesn't remove the entry (if any) in the legacy shared preferences
   @ExpoMethod
   @SuppressWarnings("unused")
@@ -389,12 +422,24 @@ public class SecureStoreModule extends ExportedModule {
     public KeyStore.SecretKeyEntry initializeKeyStoreEntry(KeyStore keyStore, ReadableArguments options) throws GeneralSecurityException {
       String keystoreAlias = getKeyStoreAlias(options);
       int keyPurposes = KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT;
-      AlgorithmParameterSpec algorithmSpec = new KeyGenParameterSpec.Builder(keystoreAlias, keyPurposes)
-          .setKeySize(AES_KEY_SIZE_BITS)
-          .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
-          .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
-          .setUserAuthenticationRequired(options.getBoolean(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY, false))
-          .build();
+      AlgorithmParameterSpec algorithmSpec;
+      if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.R) {
+        algorithmSpec = new KeyGenParameterSpec.Builder(keystoreAlias, keyPurposes)
+            .setKeySize(AES_KEY_SIZE_BITS)
+            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
+            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
+            .setUserAuthenticationParameters(5, KeyProperties.AUTH_BIOMETRIC_STRONG | KeyProperties.AUTH_DEVICE_CREDENTIAL)
+            .setUserAuthenticationRequired(options.getBoolean(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY, false))
+            .build();
+      } else {
+        algorithmSpec = new KeyGenParameterSpec.Builder(keystoreAlias, keyPurposes)
+            .setKeySize(AES_KEY_SIZE_BITS)
+            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
+            .setUserAuthenticationValidityDurationSeconds(5)
+            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
+            .setUserAuthenticationRequired(options.getBoolean(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY, false))
+            .build();
+      }
 
       KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, keyStore.getProvider());
       keyGenerator.init(algorithmSpec);
diff --git a/node_modules/expo-secure-store/build/SecureStore.d.ts b/node_modules/expo-secure-store/build/SecureStore.d.ts
index af94e3f..3e5f292 100644
--- a/node_modules/expo-secure-store/build/SecureStore.d.ts
+++ b/node_modules/expo-secure-store/build/SecureStore.d.ts
@@ -61,6 +61,28 @@ export declare type SecureStoreOptions = {
      */
     keychainAccessible?: KeychainAccessibilityConstant;
 };
+export declare enum SecurityLevel {
+    /**
+     * Indicates no enrolled authentication.
+     */
+    NONE = 0,
+    /**
+     * Indicates non-biometric authentication (e.g. PIN, Pattern).
+     */
+    SECRET = 1,
+    /**
+     * Indicates biometric authentication.
+     */
+    BIOMETRIC = 2
+}
+/**
+ * **(Android Only)**
+ * Determine what kind of authentication is enrolled on the device availible for expo-secure-store.
+ * @return Returns a promise which fulfils with [`SecurityLevel`](#securitylevel).
+ * > **Note:** On Android devices prior to M, `SECRET` can be returned if only the SIM lock has been
+ * enrolled.
+ */
+export declare function getEnrolledLevelAsync(): Promise<SecurityLevel>;
 /**
  * Returns whether the SecureStore API is enabled on the current device. This does not check the app
  * permissions.
diff --git a/node_modules/expo-secure-store/build/SecureStore.js b/node_modules/expo-secure-store/build/SecureStore.js
index 1be7f37..49da249 100644
--- a/node_modules/expo-secure-store/build/SecureStore.js
+++ b/node_modules/expo-secure-store/build/SecureStore.js
@@ -42,6 +42,34 @@ export const WHEN_UNLOCKED = ExpoSecureStore.WHEN_UNLOCKED;
  */
 export const WHEN_UNLOCKED_THIS_DEVICE_ONLY = ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;
 const VALUE_BYTES_LIMIT = 2048;
+export var SecurityLevel;
+(function (SecurityLevel) {
+    /**
+     * Indicates no enrolled authentication.
+     */
+    SecurityLevel[SecurityLevel["NONE"] = 0] = "NONE";
+    /**
+     * Indicates non-biometric authentication (e.g. PIN, Pattern).
+     */
+    SecurityLevel[SecurityLevel["SECRET"] = 1] = "SECRET";
+    /**
+     * Indicates biometric authentication.
+     */
+    SecurityLevel[SecurityLevel["BIOMETRIC"] = 2] = "BIOMETRIC";
+})(SecurityLevel || (SecurityLevel = {}));
+/**
+ * **(Android Only)**
+ * Determine what kind of authentication is enrolled on the device availible for expo-secure-store.
+ * @return Returns a promise which fulfils with [`SecurityLevel`](#securitylevel).
+ * > **Note:** On Android devices prior to M, `SECRET` can be returned if only the SIM lock has been
+ * enrolled.
+ */
+export async function getEnrolledLevelAsync() {
+    if (!ExpoSecureStore.getEnrolledLevelAsync) {
+        throw new UnavailabilityError('SecureStore', 'getEnrolledLevelAsync');
+    }
+    return await ExpoSecureStore.getEnrolledLevelAsync();
+}
 // @needsAudit
 /**
  * Returns whether the SecureStore API is enabled on the current device. This does not check the app
diff --git a/node_modules/expo-secure-store/build/SecureStore.js.map b/node_modules/expo-secure-store/build/SecureStore.js.map
index 001d1b0..0331929 100644
--- a/node_modules/expo-secure-store/build/SecureStore.js.map
+++ b/node_modules/expo-secure-store/build/SecureStore.js.map
@@ -1 +1 @@
-{"version":3,"file":"SecureStore.js","sourceRoot":"","sources":["../src/SecureStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\n\nimport ExpoSecureStore from './ExpoSecureStore';\n\nexport type KeychainAccessibilityConstant = number;\n\n// @needsAudit\n/**\n * The data in the keychain item cannot be accessed after a restart until the device has been\n * unlocked once by the user. This may be useful if you need to access the item when the phone\n * is locked.\n */\nexport const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant = ExpoSecureStore.AFTER_FIRST_UNLOCK;\n\n// @needsAudit\n/**\n * Similar to `AFTER_FIRST_UNLOCK`, except the entry is not migrated to a new device when restoring\n * from a backup.\n */\nexport const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can always be accessed regardless of whether the device is locked.\n * This is the least secure option.\n */\nexport const ALWAYS: KeychainAccessibilityConstant = ExpoSecureStore.ALWAYS;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED_THIS_DEVICE_ONLY`, except the user must have set a passcode in order to\n * store an entry. If the user removes their passcode, the entry will be deleted.\n */\nexport const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * Similar to `ALWAYS`, except the entry is not migrated to a new device when restoring from a backup.\n */\nexport const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can be accessed only while the device is unlocked by the user.\n */\nexport const WHEN_UNLOCKED: KeychainAccessibilityConstant = ExpoSecureStore.WHEN_UNLOCKED;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED`, except the entry is not migrated to a new device when restoring from\n * a backup.\n */\nexport const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;\n\nconst VALUE_BYTES_LIMIT = 2048;\n\n// @needsAudit\nexport type SecureStoreOptions = {\n  /**\n   * - iOS: The item's service, equivalent to `kSecAttrService`\n   * - Android: Equivalent of the public/private key pair `Alias`\n   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.\n   */\n  keychainService?: string;\n  /**\n   * Option responsible for enabling the usage of the user authentication methods available on the device while\n   * accessing data stored in SecureStore.\n   *\n   * - iOS: Equivalent to `kSecAccessControlUserPresence`\n   * - Android: Equivalent to `setUserAuthenticationRequired(true)` (requires API 23). Complete functionality\n   * is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`\n   * value used for the others non-authenticated operations.\n   */\n  requireAuthentication?: boolean;\n  /**\n   * Custom message displayed to the user while `requireAuthentication` option is turned on.\n   */\n  authenticationPrompt?: string;\n  /**\n   * __(iOS only)__ Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible`\n   * property. See Apple's documentation on [keychain item accessibility](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html#//apple_ref/doc/uid/TP30000897-CH204-SW18).\n   * Default value: `SecureStore.WHEN_UNLOCKED`.\n   */\n  keychainAccessible?: KeychainAccessibilityConstant;\n};\n\n// @needsAudit\n/**\n * Returns whether the SecureStore API is enabled on the current device. This does not check the app\n * permissions.\n *\n * @return Promise which fulfils witch `boolean`, indicating whether the SecureStore API is available\n * on the current device. Currently this resolves `true` on iOS and Android only.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!ExpoSecureStore.getValueWithKeyAsync;\n}\n\n// @needsAudit\n/**\n * Delete the value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that will reject if the value couldn't be deleted.\n */\nexport async function deleteItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  _ensureValidKey(key);\n\n  if (!ExpoSecureStore.deleteValueWithKeyAsync) {\n    throw new UnavailabilityError('SecureStore', 'deleteItemAsync');\n  }\n  await ExpoSecureStore.deleteValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Fetch the stored value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that resolves to the previously stored value, or `null` if there is no entry\n * for the given key. The promise will reject if an error occurred while retrieving the value.\n */\nexport async function getItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<string | null> {\n  _ensureValidKey(key);\n  return await ExpoSecureStore.getValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Store a key–value pair.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters\n * `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that will reject if value cannot be stored on the device.\n */\nexport async function setItemAsync(\n  key: string,\n  value: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  _ensureValidKey(key);\n  if (!_isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n  if (!ExpoSecureStore.setValueWithKeyAsync) {\n    throw new UnavailabilityError('SecureStore', 'setItemAsync');\n  }\n  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);\n}\n\nfunction _ensureValidKey(key: string) {\n  if (!_isValidKey(key)) {\n    throw new Error(\n      `Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".`\n    );\n  }\n}\n\nfunction _isValidKey(key: string) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key);\n}\n\nfunction _isValidValue(value: string) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  if (_byteCount(value) > VALUE_BYTES_LIMIT) {\n    console.warn(\n      'Provided value to SecureStore is larger than 2048 bytes. An attempt to store such a value will throw an error in SDK 35.'\n    );\n  }\n  return true;\n}\n\n// copy-pasted from https://stackoverflow.com/a/39488643\nfunction _byteCount(value: string) {\n  let bytes = 0;\n\n  for (let i = 0; i < value.length; i++) {\n    const codePoint = value.charCodeAt(i);\n\n    // Lone surrogates cannot be passed to encodeURI\n    if (codePoint >= 0xd800 && codePoint < 0xe000) {\n      if (codePoint < 0xdc00 && i + 1 < value.length) {\n        const next = value.charCodeAt(i + 1);\n\n        if (next >= 0xdc00 && next < 0xe000) {\n          bytes += 4;\n          i++;\n          continue;\n        }\n      }\n    }\n\n    bytes += codePoint < 0x80 ? 1 : codePoint < 0x800 ? 2 : 3;\n  }\n\n  return bytes;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SecureStore.js","sourceRoot":"","sources":["../src/SecureStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\n\nimport ExpoSecureStore from './ExpoSecureStore';\n\nexport type KeychainAccessibilityConstant = number;\n\n// @needsAudit\n/**\n * The data in the keychain item cannot be accessed after a restart until the device has been\n * unlocked once by the user. This may be useful if you need to access the item when the phone\n * is locked.\n */\nexport const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant = ExpoSecureStore.AFTER_FIRST_UNLOCK;\n\n// @needsAudit\n/**\n * Similar to `AFTER_FIRST_UNLOCK`, except the entry is not migrated to a new device when restoring\n * from a backup.\n */\nexport const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can always be accessed regardless of whether the device is locked.\n * This is the least secure option.\n */\nexport const ALWAYS: KeychainAccessibilityConstant = ExpoSecureStore.ALWAYS;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED_THIS_DEVICE_ONLY`, except the user must have set a passcode in order to\n * store an entry. If the user removes their passcode, the entry will be deleted.\n */\nexport const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * Similar to `ALWAYS`, except the entry is not migrated to a new device when restoring from a backup.\n */\nexport const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can be accessed only while the device is unlocked by the user.\n */\nexport const WHEN_UNLOCKED: KeychainAccessibilityConstant = ExpoSecureStore.WHEN_UNLOCKED;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED`, except the entry is not migrated to a new device when restoring from\n * a backup.\n */\nexport const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;\n\nconst VALUE_BYTES_LIMIT = 2048;\n\n// @needsAudit\nexport type SecureStoreOptions = {\n  /**\n   * - iOS: The item's service, equivalent to `kSecAttrService`\n   * - Android: Equivalent of the public/private key pair `Alias`\n   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.\n   */\n  keychainService?: string;\n  /**\n   * Option responsible for enabling the usage of the user authentication methods available on the device while\n   * accessing data stored in SecureStore.\n   *\n   * - iOS: Equivalent to `kSecAccessControlUserPresence`\n   * - Android: Equivalent to `setUserAuthenticationRequired(true)` (requires API 23). Complete functionality\n   * is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`\n   * value used for the others non-authenticated operations.\n   */\n  requireAuthentication?: boolean;\n  /**\n   * Custom message displayed to the user while `requireAuthentication` option is turned on.\n   */\n  authenticationPrompt?: string;\n  /**\n   * __(iOS only)__ Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible`\n   * property. See Apple's documentation on [keychain item accessibility](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html#//apple_ref/doc/uid/TP30000897-CH204-SW18).\n   * Default value: `SecureStore.WHEN_UNLOCKED`.\n   */\n  keychainAccessible?: KeychainAccessibilityConstant;\n};\n\nexport enum SecurityLevel {\n  /**\n   * Indicates no enrolled authentication.\n   */\n  NONE = 0,\n  /**\n   * Indicates non-biometric authentication (e.g. PIN, Pattern).\n   */\n  SECRET = 1,\n  /**\n   * Indicates biometric authentication.\n   */\n  BIOMETRIC = 2,\n}\n\n/**\n * **(Android Only)**\n * Determine what kind of authentication is enrolled on the device availible for expo-secure-store.\n * @return Returns a promise which fulfils with [`SecurityLevel`](#securitylevel).\n * > **Note:** On Android devices prior to M, `SECRET` can be returned if only the SIM lock has been\n * enrolled.\n */\n export async function getEnrolledLevelAsync(): Promise<SecurityLevel> {\n  if (!ExpoSecureStore.getEnrolledLevelAsync) {\n    throw new UnavailabilityError('SecureStore', 'getEnrolledLevelAsync');\n  }\n  return await ExpoSecureStore.getEnrolledLevelAsync();\n}\n\n// @needsAudit\n/**\n * Returns whether the SecureStore API is enabled on the current device. This does not check the app\n * permissions.\n *\n * @return Promise which fulfils witch `boolean`, indicating whether the SecureStore API is available\n * on the current device. Currently this resolves `true` on iOS and Android only.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!ExpoSecureStore.getValueWithKeyAsync;\n}\n\n// @needsAudit\n/**\n * Delete the value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that will reject if the value couldn't be deleted.\n */\nexport async function deleteItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  _ensureValidKey(key);\n\n  if (!ExpoSecureStore.deleteValueWithKeyAsync) {\n    throw new UnavailabilityError('SecureStore', 'deleteItemAsync');\n  }\n  await ExpoSecureStore.deleteValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Fetch the stored value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that resolves to the previously stored value, or `null` if there is no entry\n * for the given key. The promise will reject if an error occurred while retrieving the value.\n */\nexport async function getItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<string | null> {\n  _ensureValidKey(key);\n  return await ExpoSecureStore.getValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Store a key–value pair.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters\n * `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that will reject if value cannot be stored on the device.\n */\nexport async function setItemAsync(\n  key: string,\n  value: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  _ensureValidKey(key);\n  if (!_isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n  if (!ExpoSecureStore.setValueWithKeyAsync) {\n    throw new UnavailabilityError('SecureStore', 'setItemAsync');\n  }\n  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);\n}\n\nfunction _ensureValidKey(key: string) {\n  if (!_isValidKey(key)) {\n    throw new Error(\n      `Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".`\n    );\n  }\n}\n\nfunction _isValidKey(key: string) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key);\n}\n\nfunction _isValidValue(value: string) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  if (_byteCount(value) > VALUE_BYTES_LIMIT) {\n    console.warn(\n      'Provided value to SecureStore is larger than 2048 bytes. An attempt to store such a value will throw an error in SDK 35.'\n    );\n  }\n  return true;\n}\n\n// copy-pasted from https://stackoverflow.com/a/39488643\nfunction _byteCount(value: string) {\n  let bytes = 0;\n\n  for (let i = 0; i < value.length; i++) {\n    const codePoint = value.charCodeAt(i);\n\n    // Lone surrogates cannot be passed to encodeURI\n    if (codePoint >= 0xd800 && codePoint < 0xe000) {\n      if (codePoint < 0xdc00 && i + 1 < value.length) {\n        const next = value.charCodeAt(i + 1);\n\n        if (next >= 0xdc00 && next < 0xe000) {\n          bytes += 4;\n          i++;\n          continue;\n        }\n      }\n    }\n\n    bytes += codePoint < 0x80 ? 1 : codePoint < 0x800 ? 2 : 3;\n  }\n\n  return bytes;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-secure-store/src/SecureStore.ts b/node_modules/expo-secure-store/src/SecureStore.ts
index a04d9a2..9da81ad 100644
--- a/node_modules/expo-secure-store/src/SecureStore.ts
+++ b/node_modules/expo-secure-store/src/SecureStore.ts
@@ -88,6 +88,35 @@ export type SecureStoreOptions = {
   keychainAccessible?: KeychainAccessibilityConstant;
 };
 
+export enum SecurityLevel {
+  /**
+   * Indicates no enrolled authentication.
+   */
+  NONE = 0,
+  /**
+   * Indicates non-biometric authentication (e.g. PIN, Pattern).
+   */
+  SECRET = 1,
+  /**
+   * Indicates biometric authentication.
+   */
+  BIOMETRIC = 2,
+}
+
+/**
+ * **(Android Only)**
+ * Determine what kind of authentication is enrolled on the device availible for expo-secure-store.
+ * @return Returns a promise which fulfils with [`SecurityLevel`](#securitylevel).
+ * > **Note:** On Android devices prior to M, `SECRET` can be returned if only the SIM lock has been
+ * enrolled.
+ */
+ export async function getEnrolledLevelAsync(): Promise<SecurityLevel> {
+  if (!ExpoSecureStore.getEnrolledLevelAsync) {
+    throw new UnavailabilityError('SecureStore', 'getEnrolledLevelAsync');
+  }
+  return await ExpoSecureStore.getEnrolledLevelAsync();
+}
+
 // @needsAudit
 /**
  * Returns whether the SecureStore API is enabled on the current device. This does not check the app
